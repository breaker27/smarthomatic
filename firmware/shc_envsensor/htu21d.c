/*
 HTU21D Humidity Sensor 
 This code based on the library from https://github.com/sparkfun/HTU21D
 
 Software:
 Call HTU21D.Begin() in setup.
 ReadHumidity() will return a int16 containing the humidity.
 ReadTemperature() will return a int16 containing the temperature in Celsius.
 SetResolution(byte: 0b.76543210) sets the resolution of the readings.
 check_crc(message, check_value) verifies the 8-bit CRC generated by the sensor
 read_user_register() returns the user register. Used to set resolution.
 */

#include "htu21d.h"

#include "config.h"
#include "i2c.h"
#include "uart.h"
#include "util.h"

//Read the humidity
/*******************************************************************************************/
//Calc humidity and return it to the user
//Returns 998 if I2C timed out 
//Returns 999 if CRC is wrong
int16_t htu21d_readHumidity(void)
{
	//Request a humidity reading
	uint8_t cmd[0];
	cmd[0]=TRIGGER_HUMD_MEASURE_NOHOLD;
	i2c_write(HTDU21D_ADDRESS, cmd, 1);
	i2c_stop();
	//Hang out while measurement is taken. 50mS max, page 4 of datasheet.
	_delay_ms(55);
	//Comes back in three bytes, data(MSB) / data(LSB) / Checksum
	uint8_t data_raw[3];
	i2c_read(HTDU21D_ADDRESS, data_raw, 3);
	i2c_stop();


	unsigned char msb, lsb, checksum;
	msb = data_raw[0];
	lsb = data_raw[1];
	checksum = data_raw[2];

	/* //Used for testing
	byte msb, lsb, checksum;
	msb = 0x4E;
	lsb = 0x85;
	checksum = 0x6B;*/
	
	unsigned int rawHumidity = ((unsigned int) msb << 8) | (unsigned int) lsb;

	if(htu21d_check_crc(rawHumidity, checksum) != 0) return(999); //Error out

	
	//sensorStatus = rawHumidity & 0x0003; //Grab only the right two bits
	rawHumidity &= 0xFFFC; //Zero out the status bits but keep them in place
	//Given the raw humidity data, calculate the actual relative humidity
	float tempRH = rawHumidity / (float)65536; //2^16 = 65536
	float rh = -6 + (125 * tempRH); //From page 14
	rh*=100;
	
	return((int16_t)rh);
}

//Read the temperature
/*******************************************************************************************/
//Calc temperature and return it to the user
//Returns 998 if I2C timed out 
//Returns 999 if CRC is wrong
int16_t htu21d_readTemperature(void)
{
	//Request the temperature
	uint8_t cmd[0];
	cmd[0]=TRIGGER_TEMP_MEASURE_NOHOLD;
	i2c_write(HTDU21D_ADDRESS, cmd, 1);
	i2c_stop();
	//Hang out while measurement is taken. 50mS max, page 4 of datasheet.
	_delay_ms(55);
	//Comes back in three bytes, data(MSB) / data(LSB) / Checksum
	uint8_t data_raw[3];
	i2c_read(HTDU21D_ADDRESS, data_raw, 3);
	i2c_stop();
	//Wait for data to become available
	
	unsigned char msb, lsb, checksum;
	msb = data_raw[0];
	lsb = data_raw[1];
	checksum = data_raw[2];

	/* //Used for testing
	byte msb, lsb, checksum;
	msb = 0x68;
	lsb = 0x3A;
	checksum = 0x7C; */

	unsigned int rawTemperature = ((unsigned int) msb << 8) | (unsigned int) lsb;

	if(htu21d_check_crc(rawTemperature, checksum) != 0) return(999); //Error out

	//sensorStatus = rawTemperature & 0x0003; //Grab only the right two bits
	rawTemperature &= 0xFFFC; //Zero out the status bits but keep them in place

	//Given the raw temperature data, calculate the actual temperature
	float tempTemperature = rawTemperature / (float)65536; //2^16 = 65536
	float realTemperature = -46.85 + (175.72 * tempTemperature); //From page 14
	realTemperature=realTemperature*100;
	return((int16_t)realTemperature);  
}

//Set sensor resolution
/*******************************************************************************************/
//Sets the sensor resolution to one of four levels
//Page 12:
// 0/0 = 12bit RH, 14bit Temp
// 0/1 = 8bit RH, 12bit Temp
// 1/0 = 10bit RH, 13bit Temp
// 1/1 = 11bit RH, 11bit Temp
//Power on default is 0/0

void htu21d_setResolution(unsigned char resolution)
{
    uint8_t userRegister = htu21d_read_user_register(); //Go get the current register state
  userRegister &= 0b01111110; //Turn off the resolution bits
  resolution &= 0b10000001; //Turn off all other bits but resolution bits
  userRegister |= resolution; //Mask in the requested resolution bits
  
  uint8_t cmd[2];
  cmd[0]=WRITE_USER_REG;
  cmd[1]=userRegister;
  //Request a write to user register
  i2c_write(HTDU21D_ADDRESS, cmd, 2);
  i2c_stop();
}

//Read the user register
uint8_t htu21d_read_user_register(void)
{  
  //Request the user register
  uint8_t cmd[0];
	cmd[0]=READ_USER_REG;
	i2c_write(HTDU21D_ADDRESS, cmd, 1);
	i2c_stop();
  
  uint8_t userRegister[1];
	i2c_read(HTDU21D_ADDRESS, userRegister, 1);
	i2c_stop();

  return(userRegister[1]);  
}

//Give this function the 2 byte message (measurement) and the check_value byte from the HTU21D
//If it returns 0, then the transmission was good
//If it returns something other than 0, then the communication was corrupted
//From: http://www.nongnu.org/avr-libc/user-manual/group__util__crc.html
//POLYNOMIAL = 0x0131 = x^8 + x^5 + x^4 + 1 : http://en.wikipedia.org/wiki/Computation_of_cyclic_redundancy_checks
#define SHIFTED_DIVISOR 0x988000 //This is the 0x0131 polynomial shifted to farthest left of three bytes

unsigned char htu21d_check_crc(uint16_t message_from_sensor, uint8_t check_value_from_sensor)
{
  //Test cases from datasheet:
  //message = 0xDC, checkvalue is 0x79
  //message = 0x683A, checkvalue is 0x7C
  //message = 0x4E85, checkvalue is 0x6B

  uint32_t remainder = (uint32_t)message_from_sensor << 8; //Pad with 8 bits because we have to add in the check value
  remainder |= check_value_from_sensor; //Add on the check value

  uint32_t divsor = (uint32_t)SHIFTED_DIVISOR;

  for (int i = 0 ; i < 16 ; i++) //Operate on only 16 positions of max 24. The remaining 8 are our remainder and should be zero when we're done.
  {
    if( remainder & (uint32_t)1<<(23 - i) ) //Check if there is a one in the left position
      remainder ^= divsor;

    divsor >>= 1; //Rotate the divsor max 16 times so that we have 8 bits left of a remainder
  }

  return (unsigned char)remainder;
}

